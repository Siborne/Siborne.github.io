[{"content":"用户登录验证流程（基于 JWT） 用户输入用户名和密码，并通过 HTTPS 请求发送至服务器。\n服务器验证凭据：\n若验证成功，则生成一个 签名过的 JWT（JSON Web Token） 并返回给客户端； 若失败，则返回错误信息。 客户端（如浏览器）收到 JWT 后，将其保存（通常存于 localStorage​ 或 ​cookie​​ 中,Vue.js框架可使用Vuex​或Pinia）。\n后续每次请求​，客户端将 JWT 放在 HTTP 请求头（如 Authorization: Bearer \u0026lt;token\u0026gt;）中发送给服务器。\n服务器收到请求后：\n使用本地保存的密钥对 JWT 的签名进行验证； 若签名有效且未过期（通过 exp 字段判断），则认为用户已认证，返回所需数据； 否则拒绝请求。 用户退出登录时，客户端只需销毁本地存储的 token 即可，服务器无需任何操作。\nJWT 简介 JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在各方之间安全地传输信息作为 JSON 对象。它将（用户信息如用户 ID、角色等）加密到编码到 token 的 payload 中，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。\n优点是在分布式系统中，很好地解决了单点登录问题，很容易解决了session共享的问题。jwt长度较小，且可以使用URL传输(URLsafe)。\n核心特点： 无状态（Stateless） ：服务器不存储 session 信息，所有认证信息都包含在 token 中。 自包含（Self-contained） ：token 本身携带必要数据，减少数据库查询。 支持跨域与分布式系统：天然适用于微服务架构和单点登录（SSO）场景。 URL 安全：Base64Url 编码使其可安全地通过 URL、POST 参数或 HTTP Header 传输。 JWT 生成示例（Java） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** 生产 token */ public static String generateToken(Map\u0026lt;String, Object\u0026gt; claimMaps) { if (null != claimMaps) { claimMaps.forEach((key, val) -\u0026gt; { claimMaps.put(key, val.toString()); }); } return Jwts.builder() // JWT_ID,可用于每次签名唯一识别 .setId(UUID.randomUUID().toString()) // 数据压缩方式 .compressWith(CompressionCodecs.GZIP) // 签发者信息 .setIssuer(ISSUER) // 说明 .setSubject(\u0026#34;system\u0026#34;) //接收用户 .setAudience(AUDIENCE) // 签发时间 .setIssuedAt(new Date(System.currentTimeMillis())) // 过期时间戳 .setExpiration(new Date(System.currentTimeMillis() + EXPIRES_IN * 1000)) // claim信息,自定义载荷 .addClaims(claimMaps) // 签名算法以+密匙 .signWith(SIGNATURE_ALGORITHM, secretKey) .compact(); } 验证token的过程其实跟重新生成一个token的过程是一样的\n根据传递过来的header、payload以及服务端存储的密钥，重新生成一个token对比:\n如果token相同，那么标志token有效，没被修改。\n同时如果token没被修改，还可以进一步同bease64解密payload，然后根据payload中的exp有效期信息，判断token是否已经过期 注意: JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。因此做前端开发时,最好不要把JWT存放在Cookie这种容易泄露个人隐私信息的存储单元.\n优点 无状态 \u0026amp; 易扩展：非常适合分布式系统和微服务架构； 解决 Session 共享问题：无需共享 session 存储； 天然支持跨域和移动端； 减少数据库压力​：认证信息内置于 token，无需频繁查库。 缺点与风险 无法主动作废令牌\n一旦签发，在过期前始终有效。若用户登出或权限变更，服务器无法立即使旧 token 失效（除非引入黑名单机制，但这违背了无状态初衷）。 敏感信息泄露风险\nPayload 虽经 Base64 编码，但​未加密（除非使用 JWE）。切勿在 token 中存放密码等敏感数据。 必须使用 HTTPS\nJWT 通过网络传输，若使用 HTTP，极易被中间人窃取。​务必全程使用 HTTPS。 令牌体积较大\n相比传统 session ID，JWT 因包含数据而更长，可能影响性能（尤其在高频请求场景）。 补充说明 单点登录（SSO） ：JWT 天然支持，因 token 可被多个服务验证。\n首页访问控制：若需“放开首页”（即匿名访问），应在网关或拦截器中配置白名单路径，跳过 JWT 验证。\n跨域支持​：JWT 本身与 CORS 无关，但配合 Authorization Header 可轻松实现跨域认证。\n对比 Spring Session：\nSpring Session 依赖服务器端存储（如 Redis），支持主动失效； JWT 无状态，但牺牲了实时控制能力； 两者适用于不同场景，可结合使用（如用 JWT 认证，用 Redis 管理黑名单）。 增强 JWT 安全性与可控性的建议方案 尽管 JWT 具备无状态、可扩展等优势，但其“无法主动失效”的特性在某些业务场景（如用户登出、密码修改、权限变更）中确实构成挑战。为此，推荐采用以下两种互补策略来增强系统的安全控制能力：\n方案一：短期访问令牌 + 刷新令牌机制（Access Token + Refresh Token） 核心思想：\nAccess Token​：有效期较短（如 15~30 分钟），用于日常 API 认证； Refresh Token：有效期较长（如 7 天），存储于安全的 HttpOnly Cookie 或安全存储中，仅用于换取新的 Access Token。 工作流程：\n用户登录成功后，服务器返回一对令牌：access_token​ 和 refresh_token； 客户端使用 access_token 调用受保护接口； 当 access_token​ 过期时，客户端用 refresh_token​ 向认证服务申请新的 access_token； 若用户登出或修改密码，服务器​立即作废对应的 ​refresh_token​（如从数据库或 Redis 中删除）； 即使旧的 access_token 尚未过期，因其无法续期，实际有效窗口被大幅缩短。 优点：\n平衡安全性与用户体验； 登出后最多等待一个 Access Token 的生命周期（如 30 分钟）即可完全失效； 符合 OAuth 2.0 标准实践。 方案二：基于 Redis 的轻量级 Token 黑名单 / 白名单机制 实现方式 A：JTI 黑名单\n在 JWT 的 jti（JWT ID）字段中嵌入唯一标识； 用户登出、改密或权限变更时，将该 jti​ 及其过期时间存入 Redis（TTL = 原 JWT 剩余有效期）； 每次验证 JWT 时，额外检查 jti 是否存在于黑名单中； 若存在，则拒绝请求。 实现方式 B：用户会话白名单（更严格）\n每次成功登录生成 JWT 后，将其完整字符串（或哈希值）以 user_id:session_id 为键存入 Redis； 所有受保护接口在验证 JWT 签名和有效期后，​额外校验该 token 是否存在于 Redis 中； 当用户登出、改密或管理员强制下线时，删除对应 Redis 键； 此时即使 token 未过期、签名有效，也会因“不在白名单”而被拒绝。 优点：\n实现​真正的即时登出； 支持细粒度控制（如多设备管理、强制踢下线）； Redis 高性能，对系统吞吐影响极小。 注意事项：\n需合理设置 Redis 键的 TTL，避免内存无限增长； 白名单方案虽更安全，但略微牺牲了 JWT 的“完全无状态”特性，属于​有状态增强模式。 综合建议 场景 推荐方案 普通 Web 应用、移动端 App Access Token + Refresh Token（平衡安全与性能） 高安全要求系统（如金融、后台管理） Refresh Token + Redis 黑名单/白名单 需支持“多设备登录管理” 使用 Redis 白名单 + session_id 标识设备 💡 ​最佳实践：即使采用黑名单机制，也应保持 Access Token 的短期有效期（如 ≤30 分钟），以限制 Redis 存储压力和潜在攻击窗口。\n‍\n","date":"2026-01-04T00:00:00Z","image":"https://Siborne.github.io/p/jwt%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90/bannerImage_hu_2e1e41eb135995ac.png","permalink":"https://Siborne.github.io/p/jwt%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90/","title":"JWT简单解析"},{"content":"ThreadLocal介绍 从Java官方文档中的描述：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。\n我们可以得知ThreadLocal的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。\n线程并发：在多线程并发的场景下 传递数据：我们可以通过ThreadLocal在同一线程，不同组件之间传递公共变量（有点类似于Session？） 线程隔离：每个线程的变量都是独立的，不会互相影响 基本使用 在介绍Thread使用之前，我们首先认识几个Thread的常见方法\n方法声明 描述 ThreadLocal() 创建ThreadLocal对象 public void set(T value) 设置当前线程绑定的局部变量 public T get() 获取当前线程绑定的局部变量 public void remove() 移除当前线程绑定的局部变量 使用案例 我们来看下面这个案例，感受一下ThreadLocal线程隔离的特点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 需求：线程隔离 * 在多线程并发的场景下，每个线程中的变量都是相互独立的 * 线程A：设置变量1，获取变量2 * 线程B：设置变量2，获取变量2 * @author: Siborne * @create: 2025-12-30-17:03 */ public class MyDemo01 { // 变量 private String content; public String getContent() { return content; } public void setContent(String content) { this.content = content; } public static void main(String[] args) { MyDemo01 myDemo01 = new MyDemo01(); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { myDemo01.setContent(Thread.currentThread().getName() + \u0026#34;的数据\u0026#34;); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34;\\t \u0026#34; + myDemo01.getContent()); }, String.valueOf(i)).start(); } } } 运行后的效果\n1 2 3 4 5 6 7 8 9 10 ----------------------------------------- ----------------------------------------- ----------------------------------------- 3\t4的数据 ----------------------------------------- 2\t4的数据 ----------------------------------------- 1\t4的数据 4\t4的数据 0\t4的数据 从上面我们可以看到，出现了线程不隔离的问题，也就是线程1取出了线程4的内，那么如何解决呢？\n这个时候就可以用到ThreadLocal了，我们通过 set 将变量绑定到当前线程中，然后 get 获取当前线程绑定的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 需求：线程隔离 * 在多线程并发的场景下，每个线程中的变量都是相互独立的 * 线程A：设置变量1，获取变量2 * 线程B：设置变量2，获取变量2 * @author: Siborne * @create: 2025-12-30-17:03 */ public class MyDemo01 { // 变量 private String content; public String getContent() { return content; } public void setContent(String content) { this.content = content; } public static void main(String[] args) { MyDemo01 myDemo01 = new MyDemo01(); ThreadLocal\u0026lt;String\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { threadLocal.set(Thread.currentThread().getName() + \u0026#34;的数据\u0026#34;); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34;\\t \u0026#34; + threadLocal.get()); }, String.valueOf(i)).start(); } } } 我们引入ThreadLocal后，查看运行结果\n1 2 3 4 5 6 7 8 9 10 ----------------------------------------- ----------------------------------------- 4\t4的数据 ----------------------------------------- 3\t3的数据 ----------------------------------------- 2\t2的数据 ----------------------------------------- 1\t1的数据 0\t0的数据 我们发现不会出现上面的情况了，也就是当前线程只能获取线程线程存储的对象\nThreadLocal类和Synchronized关键字 Synchronized同步方式 对于上述的例子，我们完全可以通过加锁的方式来实现这个功能，我们来看一下用Synchronized代码块实现的效果：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { MyDemo03 myDemo01 = new MyDemo03(); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { synchronized (MyDemo03.class) { myDemo01.setContent(Thread.currentThread().getName() + \u0026#34;的数据\u0026#34;); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34;\\t \u0026#34; + myDemo01.getContent()); } }, String.valueOf(i)).start(); } } 运行结果如下所示，我们发现我们可以看到同样实现了功能，但是并发性降低了\n1 2 3 4 5 6 7 8 9 10 ----------------------------------------- 0\t0的数据 ----------------------------------------- 4\t4的数据 ----------------------------------------- 3\t3的数据 ----------------------------------------- 2\t2的数据 ----------------------------------------- 1\t1的数据 ThreadLocal与Synchronized的区别 虽然ThreadLocal模式与Synchronized关键字都用于处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同。\nSynchronized ThreadLocal 原理 同步机制采用以时间换空间的方式，只提供了一份变量，让不同的线程排队访问 ThreadLocal采用以空间换时间的概念，为每个线程都提供一份变量副本，从而实现同时访问而互不干扰 侧重点 多个线程之间访问资源的同步 多线程中让每个线程之间的数据相互隔离 总结：在刚刚的案例中，虽然使用ThreadLocal和Synchronized都能解决问题，但是使用ThreadLocal更为合适，因为这样可以使程序拥有更高的并发性。\n运用场景 通过以上的介绍，我们已经基本了解ThreadLocal的特点，但是它具体是运用在什么场景中的呢？接下来让我们看一个案例：事务操作\n转账案例 这里们先构建一个简单的转账场景：有一个数据表account，里面有两个用户 jack 和 Rose，用户Jack给用户Rose转账。案例的实现主要是用mysql数据库，JDBC和C3P0框架，以下是详细代码\n引入事务 案例中转账涉及两个DML操作：一个转出，一个转入。这些操作是需要具备原子性的，不可分割。不然有可能出现数据修改异常情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class AccountService { public boolean transfer(String outUser, String isUser, int money) { AccountDao ad = new AccountDao(); try { // 转出 ad.out(outUser, money); // 模拟转账过程中的异常 int i = 1/0; // 转入 ad.in(inUser, money); } catch(Exception e) { e.printStackTrace(); return false; } return true; } } 所以这里就需要操作事务，来保证转入和转出具备原子性，要么成功，要么失败。\nJDBC中关于事务操作的API\nConnection接口的方法 作用 void setAutoCommit(false) 禁用事务自动提交（改为手动提交） void commit() 提交事务 void rollbakc() 回滚事务 开启事务的注意点\n为了保证所有操作在一个事务中，案例中使用的连接必须是同一个；service层开启事务的connection需要跟dao层访问数据库的connection保持一致\n线程并发情况下，每个线程只能操作各自的connection，也就是线程隔离\n常规解决方法 基于上面给出的前提，大家通常想到的解决方法\n从service层将connection对象向dao层传递 加锁 常规解决方法的弊端 提高代码的耦合度（因为我们需要从service 层 传入 connection参数） 降低程序的性能（加了同步代码块，失去了并发性） 这个时候就可以通过ThreadLocal和当前线程进行绑定，来降低代码之间的耦合\n使用ThreadLocal解决 针对上面出现的情况，我们需要对原来的JDBC连接池对象进行更改\n将原来从连接池中获取对象，改成直接获取当前线程绑定的连接对象 如果连接对象是空的 再去连接池中获取连接 将此连接对象跟当前线程进行绑定 1 2 3 4 5 6 7 8 9 ThreadLocal\u0026lt;Connection\u0026gt; tl = new ThreadLocal(); public static Connection getConnection() { Connection conn = tl.get(); if(conn == null) { conn = ds.getConnection(); tl.set(conn); } return conn; } ThreadLocal实现的好处 从上述的案例中我们可以看到，在一些特定场景下，ThreadLocal方案有两个突出的优势：\n传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题 线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失 ThreadLocal的内部结构 通过以上的学习，我们对ThreadLocal的作用有了一定的认识。现在我们一起来看一下ThreadLocal的内部结构，探究它能够实现线程数据隔离的原理。\n常见误解 如果我们不去看源代码的话，可能会猜测 ThreadLocal 是这样子设计的：每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal确实是这样设计的，但现在早已不是了。\n现在的设计 但是，JDK后面优化了设计方案，在JDK8中 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value 才是真正要存储的值object。具体的过程是这样的：\n每个Thread线程内部都有一个Map（ThreadLocalMap） Map里面存储ThreadLocal对象（key）和线程的变量副本（value） Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 对比 从上面变成JDK8的设计有什么好处？\n每个Map存储的Entry数量变少，因为原来的Entry数量是由Thread决定，而现在是由ThreadLocal决定的 真实开发中，Thread的数量远远大于ThreadLocal的数量 当Thread销毁的时候，ThreadLocalMap也会随之销毁，因为ThreadLocal是存放在Thread中的，随着Thread销毁而消失，能降低开销。 ThreadLocal核心方法源码 基于ThreadLocal的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。 除了构造方法之外，ThreadLocal对外暴露的方法有以下4个\n方法声明 描述 protected T initialValue() 返回当前线程局部变量的初始值 public void set(T value) 返回当前线程绑定的局部变量 public T get() 获取当前线程绑定的局部变量 public void remove() 移除当前线程绑定的局部变量 以下是这4个方法的详细源码分析（为了保证思路清晰，ThreadLocalMap部分暂时不展开，下一个知识点详解）\nset方法 代码流程\n首先获取当前线程，并根据当前线程获取一个Map 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key） 如果Map为空，则给该线程创建Map，并设置初始化值 get方法 代码执行流程\n首先获取当前线程，根据当前线程获取一个Map 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entrye，否则转到第四步 如果e不为null，则返回e.value，否则转到第四步 Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map 总结：先获取当前线程的ThreadLocal变量，如果存在则返回值，不存在则创建并返回初始值\nremove方法 代码执行流程\n首先获取当前线程，并根据当前线程获取一个Map 如果获取的Map不为空，则移除当前ThreadLocal对象对应的Entry initialValue方法 此方法的作用是返回该线程局部变量的初始值。\n这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行1次。 这个方法缺省实现直接返回一个null。 如果想要一个除null之外的初始值，可以重写此方法。（备注：该方法是一个protected的方法，显然是为了让子类覆盖而设计的） ThreadLocalMap源码分析 在分析ThreadLocal方法的时候，我们了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。 ThreadLocalMap的源码相对比较复杂，我们从以下三个方面进行讨论。\n基本结构 ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。\n成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 初始容量 - 必须是2的整次幂 **/ private static final int INITIAL_CAPACITY = 16; /** *存放数据的table ，Entry类的定义在下面分析，同样，数组的长度必须是2的整次幂 **/ private Entry[] table; /** *数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值 **/ private int size = 0; /** *进行扩容的阈值，表使用量大于它的时候进行扩容 **/ private int threshold; // Default to 0 跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量；table是一个Entry类型的数组，用于存储数据；size代表表中的存储数目；threshold代表需要扩容时对应的size的阈值。\n存储结构 - Entry 1 2 3 4 5 6 7 8 9 10 11 /* *Entry继承WeakRefefence，并且用ThreadLocal作为key. 如果key为nu11（entry.get（）==nu11），意味着key不再被引用， *因此这时候entry也可以从table中清除。 */ static class Entry extends weakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt;{ object value；Entry（ThreadLocal\u0026lt;？\u0026gt;k，object v）{ super(k); value = v; }} 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。\n另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。\n弱引用和内存泄漏 有些程序员在使用ThreadLocal的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟Entry中使用了弱引用的key有关系。这个理解其实是不对的。\n我们先来回顾这个问题中涉及的几个名词概念，再来分析问题。\n内存泄漏相关概念 Memory overflow：内存溢出，没有足够的内存提供申请者使用。\nMemory leak：内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统溃等严重后果。I内存泄漏的堆积终将导致内存溢出。\n弱引用相关概念 Java中的引用有4种类型：强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：\n强引用（\u0026ldquo;Strong\u0026quot;Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。\n弱引用（WeakReference），垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。\n如果key使用强引用，那么会出现内存泄漏？ 假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗？\n此时ThreadLocal的内存图（实线表示强引用）如下：\n假设在业务代码中使用完ThreadLocal，threadLocal Ref被回收了 但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收。 在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链 threadRef-\u0026gt;currentThread-\u0026gt;threadLocalMap-\u0026gt;entry，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。 也就是说，ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。\n如果key使用弱引用，那么会出现内存泄漏？ 同样假设在业务代码中使用完ThreadLocal，threadLocal Ref被回收了。 由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例，所以threadloca就可以顺利被gc回收，此时Entry中的key=null。 但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-\u0026gt;currentThread-\u0026gt;threadLocalMap-\u0026gt;entry-\u0026gt; value，value不会被回收，而这块value永远不会被访问到了，导致value内存泄漏。 也就是说，ThreadLocalMap中的key使用了弱引用，也有可能内存泄漏。\n出现内存泄漏的真实原因 比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？\n细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：\n没有手动删除这个Entry CurrentThread依然运行 第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。\n第二点稍微复杂一点，由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal的使用，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。\n综上，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread-样长，如果没有手动删除对应key就会导致内存泄漏。\n为什么要使用弱引用？ 根据刚才的分析，我们知道了：无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。\n要避免内存泄漏有两种方式：\n使用完ThreadLocal，调用其remove方法删除对应的Entry 使用完ThreadLocal，当前Thread也随之运行结束 相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的，而是接着放入了线程池中。\n也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题。 那么为什么key要用弱引用呢？\n事实上，在ThreadLocalMap中的 set / getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为nul的。\n这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，弱引用比强引用可以多一层保障：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set，get，remove中的任一方法的时候会被清除，从而避免内存泄漏。\nHash冲突的解决 hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索，来研究一下ThreadLocalMap的核心源码。\n首先从ThreadLocal的set方法入手\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void set（T value）{ Threadt=Thread.currentThread(); ThreadLoca1.ThreadLocalMap map=getMap(t); if（mapl @= nu11） //调用了ThreadLocalMap的set方法I map.set(this，value); else createMap（t，value); } ThreadLocal.ThreadLocalMap getMap（Thread t）{ return t.threadLocals； } void createMap（Thread t，T firstValue）{ //调用了ThreadLocalMap的构造方法 t.threadlocals=new ThreadLocal.ThreadtocalMap(this，firstValue); 这个方法我们刚才分析过，其作用是设置当前线程绑定的局部变量\n首先获取当前线程，并根据当前线程获取一个Map 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key)（这里调用了ThreadLocalMap的set方法） 如果Map为空，则给该线程创建Map，并设置初始值（这里调用了ThreadLocalMap的构造方法） 这段代码有两个地方分别涉及到ThreadLocalMap的两个方法，我们接着分析这两个方法\n构造方法 ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue)\n构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold。\n重点分析：int i = firstKey.threadLocalHashCode \u0026amp; ( INITIAL_CAPACITY - 1)\n关于：threadLocalHashCode\n这里定义了一个Atomiclnteger类型，每次获取当前值并加上HASHINCREMENT，HASH_INCREMENT = 0x61c88647，这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里，也就是EntryI table中，这样做可以尽量避免hash冲突。\n关于\u0026amp;（INITIAL_CAPACITY-1）\n计算hash的时候里面采用了hashCode\u0026amp;（size-1）的算法，这相当于取模运算hashCode%size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证保证在索引不越界的前提下，使得hash发生冲突的次数减小。\nGet方法 代码执行流程\n首先还是根据key计算出索引i，然后查找位置上的Entry， 若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值， 若是Entry存在，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry， 不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，那么就在这个null的位置新建一个Entry，并且插入，同时size增加1。 最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz是否\u0026gt;= thresgold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。\n线性探测法解决Hash冲突 该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。\n举个例子，假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将1401得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推，直到可以插入。\n按照上面的描述，可以把Entry table看成一个环形数组。\nThreadLocal使用场景 源码使用场景 ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改。\n例如，用于 Spring实现事务隔离级别的源码\nSpring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。\nSpring框架里面就是用的ThreadLocal来实现这种隔离，主要是在TransactionSynchronizationManager这个类里面，代码如下所示:\n1 2 3 4 5 6 7 8 9 10 private static final Log logger = LogFactory.getLog(TransactionSynchronizationManager.class); private static final ThreadLocal\u0026lt;Map\u0026lt;Object, Object\u0026gt;\u0026gt; resources = new NamedThreadLocal\u0026lt;\u0026gt;(\u0026#34;Transactional resources\u0026#34;); private static final ThreadLocal\u0026lt;Set\u0026lt;TransactionSynchronization\u0026gt;\u0026gt; synchronizations = new NamedThreadLocal\u0026lt;\u0026gt;(\u0026#34;Transaction synchronizations\u0026#34;); private static final ThreadLocal\u0026lt;String\u0026gt; currentTransactionName = new NamedThreadLocal\u0026lt;\u0026gt;(\u0026#34;Current transaction name\u0026#34;); Spring的事务主要是ThreadLocal和AOP去做实现的，我这里提一下，大家知道每个线程自己的链接是靠ThreadLocal保存的就好了\n用户使用场景1 除了源码里面使用到ThreadLocal的场景，你自己有使用他的场景么？\n之前我们上线后发现部分用户的日期居然不对了，排查下来是SimpleDataFormat的锅，当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。\n其实要解决这个问题很简单，让每个线程都new 一个自己的 SimpleDataFormat就好了，但是1000个线程难道new1000个SimpleDataFormat？\n所以当时我们使用了线程池加上ThreadLocal包装SimpleDataFormat，再调用initialValue让每个线程有一个SimpleDataFormat的副本，从而解决了线程安全的问题，也提高了性能。\n用户使用场景2 我在项目中存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文（Context），它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。\n使用到类似责任链模式，给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，对象参数就传不进去了，所以我使用到了ThreadLocal去做了一下改造，这样只需要在调用前在ThreadLocal中设置参数，其他地方get一下就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 before void work(User user) { getInfo(user); checkInfo(user); setSomeThing(user); log(user); } then void work(User user) { try{ threadLocalUser.set(user); // 他们内部 User u = threadLocalUser.get(); 就好了 getInfo(); checkInfo(); setSomeThing(); log(); } finally { threadLocalUser.remove(); } } 我看了一下很多场景的cookie，session等数据隔离都是通过ThreadLocal去做实现的\n在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。\n1 2 3 4 5 6 7 static final ThreadLocal\u0026lt;Looper\u0026gt; sThreadLocal = new ThreadLocal\u0026lt;Looper\u0026gt;(); private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } 参考 https://blog.csdn.net/qq_35190492/article/details/107599875\n","date":"2025-12-30T00:00:00Z","image":"https://Siborne.github.io/p/%E5%AF%B9threadlocal%E7%9A%84%E7%90%86%E8%A7%A3/bannerImage_hu_59413b4dee3a2580.jpg","permalink":"https://Siborne.github.io/p/%E5%AF%B9threadlocal%E7%9A%84%E7%90%86%E8%A7%A3/","title":"对ThreadLocal的理解"},{"content":"为什么使用 Scoop Scoop官网网址\n在 Windows 下，搭建开发环境一直是一个复杂且困难的问题。由于没有一个统一的标准，导致各种开发环境的安装方式差异巨大，需要付出很多不必要的时间成本。而 Scoop 可以帮助你统一安装并管理常见的开发软件，省去了手动下载安装，配置环境变量等繁琐步骤。\n例如安装 python 和 nodejs 只需要执行：\n1 2 scoop install python scoop install nodejs 安装 Scoop 亲测+官方安装方法\n微软商店安装最新版Powershell\n打开PowerShell，输入以下指令\n1 2 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression 出现下图，即为安装成功\nScoop 需要 Windows PowerShell 5.1 或者 PowerShell 作为运行环境，如果你使用的是 Windows 10 及以上版本，Windows PowerShell 是内置在系统中的。而 Windows 7 内置的 Windows PowerShell 版本过于陈旧，你需要手动安装新版本的 PowerShell。\n由于发现很多同学在设置 Windows 用户时使用了中文用户名，导致了用户目录也变成了中文名。如果按照 Scoop 的默认方式将软件安装到用户目录下，可能会造成部分软件执行错误。所以这里推荐安装到自定义目录，如果需要其他安装方式请参考： ScoopInstaller/Install\n1 2 3 4 5 6 # 设置 PowerShell 执行策略 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # 下载安装脚本 irm get.scoop.sh -outfile \u0026#39;install.ps1\u0026#39; # 执行安装, --ScoopDir 参数指定 Scoop 安装路径 .\\install.ps1 -ScoopDir \u0026#39;C:\\Scoop\u0026#39; 使用 Scoop Scoop 的官方文档对于新手非常友好，相对于在此处赘述更推荐阅读 官方文档 或 快速入门 。\n常用命令 命令 作用 scoop bucket list 查看当前scoop安装的所有仓库 scoop search 用于搜索软件 scoop install 用于安装软件 scoop list 用于查看已安装的软件 scoop uninstall 用于卸载软件 scoop bucket 用于管理仓库 scoop update 用于更新软件 scoop config proxy 为soop设置代理 scoop reset 用于切换软件版本 Q\u0026amp;A Scoop 能配置镜像源吗？ Scoop 社区仅维护安装配置，所有的软件都是从该软件官方提供的下载链接进行下载，所以无法提供镜像源。如果因为你的网络环境导致多次下载失败，那么你需要一点点 魔法。\n为什么找不到 Java8？ 原因同上，官方已不再提供 Java8 的下载链接，推荐使用 ojdkbuild8 替代。\n我需要安装 python2 该如何操作？ 对于已经过时弃用的软件，Scoop 社区会将其从 ScoopInstaller/Main 中移除并将其添加到 ScoopInstaller/Versions 中。如果你需要这些软件的话需要手动添加 bucket：\n1 2 scoop bucket add versions scoop install python27 ‍\n","date":"2025-12-28T00:00:00Z","image":"https://Siborne.github.io/p/scoop/bannerImage_hu_dabdbfa70851471a.png","permalink":"https://Siborne.github.io/p/scoop/","title":"Scoop"},{"content":"1.标题语法 1 2 3 # 一级标题 ## 二级标题 ### 三级标题 以此类推，打完#要加上空格，以确保不同的Markdown程序之间的兼容性\n2.段落语法 要创建段落，请使用空白行将一行或多行文本进行分隔。\n1 2 这是第一段的段落 这是第二段的段落 请不要在段落面前加入空格或者制表符(TAB)\n3.换行语法 1 2 按下回车即可换行 就像这样😀 4.强调语法 通过将文本设置为粗体或斜体来强调其重要性。\n1 2 3 4 5 **这是粗体语法** *这是斜体语法* ***这是粗体和斜体同时作用*** ~~这是删除线~~ ==这是高亮== 5.引用语法 要创建块引用，请在段落前添加一个 \u0026gt; 符号。\n1 \u0026gt;这就是单行引用 这就是单行引用\n1 2 3 4 5 \u0026gt;第一行引用 \u0026gt; \u0026gt; \u0026gt; \u0026gt;第二行引用 第一行引用\n第二行引用\n第一层外\n# 效果看起来很不错! 这是无序列表第一行! 这是无序列表第二行! 效果如同我们想象的那样出现\n6. 列表语法 可以将多个条目组织成有序或无序列表。\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n1 2 3 4 1. 第一件物品 2. 第二件物品 3. 第三件物品 4. LOLOLOLOL 第一件物品 第二件物品 第三件物品 LOLOLOLOL 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 () 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。注意跟符号之间有空格\n1 2 3 4 - 第一件物品 - 第二件物品 - 第三件没了 - 再看一下上一行 第一件物品 第二件物品 第三届没了 再看一下上一行 1 2 3 4 5 6 无序列表四种符号均可使用 但是不能混用,例如: - 第一件物品 + 第二件物品 - 第三件没了 * 再看一下上一行 要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示\n1 2 3 4 5 6 * This is the first list item. * Here\u0026#39;s the second list item. \u0026gt; I need to add another paragraph below the second list item. * And here\u0026#39;s the third list item. 123\n123213\n666\n测试\n7.代码语法 要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。\n1 一句话里面掺一些`代码` 一句话里面掺一些代码\n如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。\n1 ``Use `code` in your Markdown file.`` Use code in your Markdown file.\n围栏式代码块 1 2 3 4 5 6 7 8 9 10 11 12 ‍```json { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } ‍``` { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } 8.分割线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (\u0026mdash;) 或下划线 (___) ，并且不能包含其他内容。\n1 2 3 *** --- _________ 1 篇文章0 订阅\n订阅专栏\n8.分隔线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (\u0026mdash;) 或下划线 (___) ，并且不能包含其他内容。\n1 2 3 *** --- _________ 为了兼容性，请在分隔线的前后均添加空白行。\n9.链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：超链接显示名\n1 [不懂就去问百度](http://www.baidu.com) 不懂就去问百度\n带title的链接语法 1 [不懂就去问百度](http://www.baidu.com \u0026#34;这是百度哦😙\u0026#34;) 不懂就去问百度\n网址和Email地址 1 2 3 \u0026lt;www.bilibili.com\u0026gt; \u0026lt;892920290@qq.com\u0026gt; \u0026lt;www.bilibili.com\u0026gt;\n\u0026lt;904389425.com\u0026gt;\n思源笔记好像用不了，其他Markdown程序也许能用\n带格式化的链接 1 2 3 I love supporting the **[EFF](https://eff.org)**. This is the *[Markdown Guide](https://www.markdownguide.org)*. See the section on [`code`](#code). I love supporting the EFF. This is the Markdown Guide. See the section on code​.\n脚注 1 [^footnote]: 这是个脚注 思源笔记好像用不了，其他Markdown程序也许能用\n10.图片语法 要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。\n1 ![W!](https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/Markdown%E4%BD%BF%E7%94%A8/w.jpg) 带链接的图像 1 [![风景图](https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/Markdown%E4%BD%BF%E7%94%A8/small095125P47QH1707616285.jpg)](https://www.baidu.com) 11.转义字符语法 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。\n1 \\* Without the backslash, this would be a bullet in an unordered list. * Without the backslash, this would be a bullet in an unordered list.\n特殊字符自动转义 在 HTML 文件中，有两个字符需要特殊处理： \u0026lt; 和 \u0026amp; 。 \u0026lt; 符号用于起始标签，\u0026amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 \u0026lt; 和 \u0026amp;。\n例如:\n1 2 http://images.google.com/images?num=30\u0026amp;q=larry+bird http://images.google.com/images?num=30\u0026amp;amp;q=larry+bird 12.内嵌 HTML 标签 HTML 的行级內联标签如 、、 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 或 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。\nHTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。\n1 **这一段话既可以这么加粗**,\u0026lt;strong\u0026gt;也可以这么加粗。\u0026lt;/strong\u0026gt; 这一段话既可以这么加粗,也可以这么加粗\n区块标签 1 2 3 4 5 6 7 8 9 10 11 在标签之前的元素 \u0026lt;div\u0026gt; \u0026lt;span\u0026gt; \u0026lt;strong\u0026gt; span标签内的元素 \u0026lt;/strong\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 在标签之后的元素 在标签之前的元素\n​\tspan标签内的元素\n在标签之后的元素\n在标签之后的元素注意：在 HTML 块级标签内不能使用 Markdown 语法。例如 italic and bold\n将不起作用。\n感谢观看\u0026hellip;. 教程参考：Markdown半小时快速入门-CSDN博客\n","date":"2025-12-27T00:00:00Z","image":"https://Siborne.github.io/p/computer-tools/bannerImage_hu_65b4680a06fca88e.jpg","permalink":"https://Siborne.github.io/p/computer-tools/","title":"Markdown"}]